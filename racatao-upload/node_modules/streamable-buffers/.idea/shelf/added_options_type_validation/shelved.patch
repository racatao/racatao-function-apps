Index: test/readable_streambuffer.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'use strict';\n\nvar expect = require('chai').expect;\nvar fixtures = require('./fixtures');\nvar streamBuffer = require('../lib/streambuffer');\n\ndescribe('A default ReadableStreamBuffer', function() {\n  beforeEach(function() {\n    this.buffer = new streamBuffer.ReadableStreamBuffer();\n  });\n\n  it('is a Stream', function() {\n    expect(this.buffer).to.be.an.instanceOf(require('stream').Stream);\n  });\n\n  it('is empty by default', function() {\n    expect(this.buffer.size()).to.equal(0);\n  });\n\n  it('has default backing buffer size', function() {\n    expect(this.buffer.maxSize()).to.equal(streamBuffer.DEFAULT_INITIAL_SIZE);\n  });\n\n  describe('when stopped', function() {\n    beforeEach(function() {\n      this.buffer.stop();\n    });\n\n    it('throws error on calling stop() again', function() {\n      expect(this.buffer.stop.bind(this.buffer)).to.throw(Error);\n    });\n\n    it('throws error on calls to put()', function() {\n      expect(this.buffer.put.bind(this.buffer)).to.throw(Error);\n    });\n  });\n\n  describe('when error', function() {\n    beforeEach(function() {\n      this.buffer.error();\n    });\n\n    it('throws error on calling error() again', function() {\n      expect(this.buffer.error.bind(this.buffer)).to.throw(Error);\n    });\n\n    it('throws error on calls to put()', function() {\n      expect(this.buffer.put.bind(this.buffer)).to.throw(Error);\n    });\n\n    it('emits error event', function(done) {\n      this.buffer.on('error', function(err) {\n        done();\n      });\n      this.buffer.read();\n    });\n\n  });\n\n  it('emits end event when stopped', function(done) {\n    this.buffer.on('end', done);\n    this.buffer.stop();\n    this.buffer.read();\n  });\n\n  it('emits end event after data, when stopped', function(done) {\n    var that = this;\n    var str = '';\n    this.buffer.on('readable', function() {\n      str += (that.buffer.read() || new Buffer(0)).toString('utf8');\n    });\n    this.buffer.on('end', function() {\n      expect(str).to.equal(fixtures.unicodeString);\n      done();\n    });\n    this.buffer.put(fixtures.unicodeString);\n    this.buffer.stop();\n  });\n\n  describe('when writing binary data', function() {\n    beforeEach(function(done) {\n      var that = this;\n      this.buffer.put(fixtures.binaryData);\n\n      this.buffer.once('readable', function() {\n        that.data = that.buffer.read();\n        done();\n      });\n    });\n\n    it('results in a Buffer', function() {\n      expect(this.data).to.be.an.instanceOf(Buffer);\n    });\n\n    it('with the correct data', function() {\n      expect(this.data).to.deep.equal(fixtures.binaryData);\n    });\n  });\n\n  describe('when writing binary data larger than initial backing buffer size', function() {\n    beforeEach(function() {\n      this.buffer.pause();\n      this.buffer.put(fixtures.largeBinaryData);\n    });\n\n    it('buffer is correct size', function() {\n      expect(this.buffer.size()).to.equal(fixtures.largeBinaryData.length);\n    });\n\n    it('backing buffer is correct size', function() {\n      expect(this.buffer.maxSize()).to.equal(streamBuffer.DEFAULT_INITIAL_SIZE + streamBuffer.DEFAULT_INCREMENT_AMOUNT);\n    });\n  });\n});\n\ndescribe('A ReadableStreamBuffer using custom chunk size', function() {\n  beforeEach(function(done) {\n    var that = this;\n\n    this.buffer = new streamBuffer.ReadableStreamBuffer({\n      chunkSize: 2\n    });\n\n    this.buffer.once('readable', function() {\n      that.data = that.buffer.read();\n      done();\n    });\n    this.buffer.put(fixtures.binaryData);\n  });\n\n  it('yields a Buffer with the correct data', function() {\n    expect(this.data).to.deep.equal(fixtures.binaryData.slice(0, 2));\n  });\n});\n\ndescribe('A ReadableStreamBuffer using custom frequency', function() {\n  beforeEach(function(done) {\n    var that = this;\n    var startTime = new Date().getTime();\n\n    this.buffer = new streamBuffer.ReadableStreamBuffer({\n      frequency: 300\n    });\n\n    this.buffer.once('readable', function() {\n      that.time = new Date().getTime() - startTime;\n      done();\n    });\n    this.buffer.put(fixtures.binaryData);\n  });\n\n  it('gave us data after the correct amount of time', function() {\n    // Wtfux: sometimes the timer is coming back a millisecond or two\n    // faster. So we do a 'close-enough' assertion here ;)\n    expect(this.time).to.be.at.least(295);\n  });\n});
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/readable_streambuffer.test.js	(date 1503817678000)
+++ test/readable_streambuffer.test.js	(revision )
@@ -154,4 +154,52 @@
     // faster. So we do a 'close-enough' assertion here ;)
     expect(this.time).to.be.at.least(295);
   });
-});
\ No newline at end of file
+});
+
+describe('A ReadableStreamBuffer constructor', function() {
+
+  it('should throw an Error when supplying non-integer value for chunkSize option', function() {
+    var constrFloat = function() { new streamBuffer.ReadableStreamBuffer({chunkSize: 42.5}); };
+    var constrString = function() { new streamBuffer.ReadableStreamBuffer({chunkSize: 'some'}); };
+    var constrObject = function() { new streamBuffer.ReadableStreamBuffer({chunkSize: {}}); };
+    var constrFunction = function() { new streamBuffer.ReadableStreamBuffer({chunkSize: function() {}}); };
+    expect(constrFloat).to.throw(Error);
+    expect(constrString).to.throw(Error);
+    expect(constrObject).to.throw(Error);
+    expect(constrFunction).to.throw(Error);
+  });
+
+  it('should throw an Error when supplying non-integer value for frequency option', function() {
+    var constrFloat = function() { new streamBuffer.ReadableStreamBuffer({frequency: 42.5}); };
+    var constrString = function() { new streamBuffer.ReadableStreamBuffer({frequency: 'some'}); };
+    var constrObject = function() { new streamBuffer.ReadableStreamBuffer({frequency: {}}); };
+    var constrFunction = function() { new streamBuffer.ReadableStreamBuffer({frequency: function() {}}); };
+    expect(constrFloat).to.throw(Error);
+    expect(constrString).to.throw(Error);
+    expect(constrObject).to.throw(Error);
+    expect(constrFunction).to.throw(Error);
+  });
+
+  it('should throw an Error when supplying non-integer value for initialSize option', function() {
+    var constrFloat = function() { new streamBuffer.ReadableStreamBuffer({initialSize: 42.5}); };
+    var constrString = function() { new streamBuffer.ReadableStreamBuffer({initialSize: 'some'}); };
+    var constrObject = function() { new streamBuffer.ReadableStreamBuffer({initialSize: {}}); };
+    var constrFunction = function() { new streamBuffer.ReadableStreamBuffer({initialSize: function() {}}); };
+    expect(constrFloat).to.throw(Error);
+    expect(constrString).to.throw(Error);
+    expect(constrObject).to.throw(Error);
+    expect(constrFunction).to.throw(Error);
+  });
+
+  it('should throw an Error when supplying non-integer value for incrementAmount option', function() {
+    var constrFloat = function() { new streamBuffer.ReadableStreamBuffer({incrementAmount: 42.5}); };
+    var constrString = function() { new streamBuffer.ReadableStreamBuffer({incrementAmount: 'some'}); };
+    var constrObject = function() { new streamBuffer.ReadableStreamBuffer({incrementAmount: {}}); };
+    var constrFunction = function() { new streamBuffer.ReadableStreamBuffer({incrementAmount: function() {}}); };
+    expect(constrFloat).to.throw(Error);
+    expect(constrString).to.throw(Error);
+    expect(constrObject).to.throw(Error);
+    expect(constrFunction).to.throw(Error);
+  });
+
+});
Index: package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"name\": \"streamable-buffers\",\n  \"version\": \"3.1.2\",\n  \"description\": \"Buffer-backed Streams for reading and writing.\",\n  \"keywords\": [\n    \"memory streams\",\n    \"streams\",\n    \"buffer streams\"\n  ],\n  \"author\": {\n    \"name\": \"Genry Manashirov\",\n    \"email\": \"henrydev10@gmail.com\"\n  },\n  \"main\": \"./lib/streambuffer.js\",\n  \"engines\": {\n    \"node\": \">= 0.12.0\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"chai\": \"~4.1.1\",\n    \"eslint\": \"~3.18.0\",\n    \"mocha\": \"~3.5.0\",\n    \"istanbul\": \"1.1.0-alpha.1\",\n    \"string-to-stream\": \"~1.1.0\",\n    \"uuid\": \"~3.1.0\"\n  },\n  \"license\": \"Unlicense\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/genrym/streamable-buffers.git\"\n  },\n  \"scripts\": {\n    \"lint\": \"eslint test/ lib/\",\n    \"test\": \"istanbul cover _mocha test/**/*.test.js\"\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- package.json	(date 1503817678000)
+++ package.json	(revision )
@@ -21,8 +21,7 @@
     "eslint": "~3.18.0",
     "mocha": "~3.5.0",
     "istanbul": "1.1.0-alpha.1",
-    "string-to-stream": "~1.1.0",
-    "uuid": "~3.1.0"
+    "string-to-stream": "~1.1.0"
   },
   "license": "Unlicense",
   "repository": {
Index: change_log.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>This file contains the changes by version since the fork\n========================================================\nv3.1.2\n    - WritableStreamBuffer - fixed 'error' event is not emitted when the buffer was overflown with more than limit\n      size\n\nv3.1.0\n    - ReadableStreamBuffer.error() added - will simulate an error in stream\n    - WritableStreamBuffer now supports 'limit' option upon creation - will throw an error if more than 'limit'\n      bytes were written\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- change_log.txt	(date 1503817678000)
+++ change_log.txt	(revision )
@@ -1,5 +1,8 @@
 This file contains the changes by version since the fork
 ========================================================
+v3.1.3
+    - Added options type validation
+
 v3.1.2
     - WritableStreamBuffer - fixed 'error' event is not emitted when the buffer was overflown with more than limit
       size
Index: lib/readable_streambuffer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'use strict';\n\nvar stream = require('stream');\nvar constants = require('./constants');\nvar util = require('util');\n\nvar ReadableStreamBuffer = module.exports = function(opts) {\n  var that = this;\n  opts = opts || {};\n\n  stream.Readable.call(this, opts);\n\n  this.stopped = false;\n  this.err = false;\n\n  var frequency = opts.hasOwnProperty('frequency') ? opts.frequency : constants.DEFAULT_FREQUENCY;\n  var chunkSize = opts.chunkSize || constants.DEFAULT_CHUNK_SIZE;\n  var initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;\n  var incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;\n\n  var size = 0;\n  var buffer = new Buffer(initialSize);\n\n  var sendData = function() {\n    var amount = Math.min(chunkSize, size);\n    var sendMore = false;\n\n    if (amount > 0) {\n      var chunk = null;\n      chunk = new Buffer(amount);\n      buffer.copy(chunk, 0, 0, amount);\n\n      sendMore = that.push(chunk) !== false;\n\n      buffer.copy(buffer, 0, amount, size);\n      size -= amount;\n    }\n\n    if(size === 0 && that.stopped) {\n      that.push(null);\n    }\n\n    if (sendMore) {\n      sendData.timeout = setTimeout(sendData, frequency);\n    }\n    else {\n      sendData.timeout = null;\n    }\n\n    if (that.err) {\n      that.push([]);\n    }\n  };\n\n  this.stop = function() {\n    if (this.stopped) {\n      throw new Error('stop() called on already stopped ReadableStreamBuffer');\n    }\n    this.stopped = true;\n\n    if (size === 0) {\n      this.push(null);\n    }\n  };\n\n  this.error = function() {\n    if (this.stopped) {\n      throw new Error('error(err) called on already stopped ReadableStreamBuffer');\n    }\n    this.stopped = true;\n    this.err = true;\n  };\n\n  this.size = function() {\n    return size;\n  };\n\n  this.maxSize = function() {\n    return buffer.length;\n  };\n\n  var increaseBufferIfNecessary = function(incomingDataSize) {\n    if((buffer.length - size) < incomingDataSize) {\n      var factor = Math.ceil((incomingDataSize - (buffer.length - size)) / incrementAmount);\n\n      var newBuffer = new Buffer(buffer.length + (incrementAmount * factor));\n      buffer.copy(newBuffer, 0, 0, size);\n      buffer = newBuffer;\n    }\n  };\n\n  this.put = function(data, encoding) {\n    if (that.stopped) {\n      throw new Error('Tried to write data to a stopped ReadableStreamBuffer');\n    }\n\n    if(Buffer.isBuffer(data)) {\n      increaseBufferIfNecessary(data.length);\n      data.copy(buffer, size, 0);\n      size += data.length;\n    }\n    else {\n      data = data + '';\n      var dataSizeInBytes = Buffer.byteLength(data);\n      increaseBufferIfNecessary(dataSizeInBytes);\n      buffer.write(data, size, encoding || 'utf8');\n      size += dataSizeInBytes;\n    }\n  };\n\n  this._read = function() {\n    if (!sendData.timeout) {\n      sendData.timeout = setTimeout(sendData, frequency);\n    }\n  };\n};\n\nutil.inherits(ReadableStreamBuffer, stream.Readable);\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/readable_streambuffer.js	(date 1503817678000)
+++ lib/readable_streambuffer.js	(revision )
@@ -14,9 +14,13 @@
   this.err = false;
 
   var frequency = opts.hasOwnProperty('frequency') ? opts.frequency : constants.DEFAULT_FREQUENCY;
+  validateInteger(frequency, 'frequency');
   var chunkSize = opts.chunkSize || constants.DEFAULT_CHUNK_SIZE;
+  validateInteger(chunkSize, 'chunkSize');
   var initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;
+  validateInteger(initialSize, 'initialSize');
   var incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;
+  validateInteger(incrementAmount, 'incrementAmount');
 
   var size = 0;
   var buffer = new Buffer(initialSize);
@@ -113,6 +117,12 @@
       sendData.timeout = setTimeout(sendData, frequency);
     }
   };
+
+  function validateInteger(value, option) {
+    if (!Number.isInteger(value)) {
+      throw new TypeError('option ' + option + ' should be of type Integer');
+    }
+  }
 };
 
 util.inherits(ReadableStreamBuffer, stream.Readable);
