Index: lib/writable_streambuffer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'use strict';\n\nconst util = require('util');\nconst stream = require('stream');\nconst constants = require('./constants');\nconst BufferOverflowError = require('./errors').BufferOverflowError;\n\nconst WritableStreamBuffer = module.exports = function(opts) {\n  opts = opts || {};\n  opts.decodeStrings = true;\n\n  stream.Writable.call(this, opts);\n\n  const initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;\n  const incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;\n  const limit = opts.limit || constants.DEFAULT_LIMIT;\n\n  let buffer = new Buffer(initialSize);\n  let size = 0;\n\n  this.size = function() {\n    return size;\n  };\n\n  this.maxSize = function() {\n    return buffer.length;\n  };\n\n  this.getContents = function(length) {\n    if(!size) return false;\n\n    const data = new Buffer(Math.min(length || size, size));\n    buffer.copy(data, 0, 0, data.length);\n\n    if(data.length < size)\n      buffer.copy(buffer, 0, data.length);\n\n    size -= data.length;\n\n    return data;\n  };\n\n  this.getContentsAsString = function(encoding, length) {\n    if(!size) return false;\n\n    const data = buffer.toString(encoding || 'utf8', 0, Math.min(length || size, size));\n    const dataLength = Buffer.byteLength(data);\n\n    if(dataLength < size)\n      buffer.copy(buffer, 0, dataLength);\n\n    size -= dataLength;\n    return data;\n  };\n\n  const increaseBufferIfNecessary = function(incomingDataSize) {\n    if((buffer.length - size) < incomingDataSize) {\n      const factor = Math.ceil((incomingDataSize - (buffer.length - size)) / incrementAmount);\n\n      const newBuffer = new Buffer(buffer.length + (incrementAmount * factor));\n      buffer.copy(newBuffer, 0, 0, size);\n      buffer = newBuffer;\n    }\n  };\n\n  function allowedToWriteSize(chunkSize) {\n    return Math.min(chunkSize, limit - size);\n  }\n\n  this._write = function(chunk, encoding, callback) {\n    const sizeToWrite = allowedToWriteSize(chunk.length);\n    increaseBufferIfNecessary(sizeToWrite);\n    chunk.copy(buffer, size, 0, sizeToWrite);\n    size += sizeToWrite;\n    if (sizeToWrite < chunk.length) {\n      callback(new BufferOverflowError('Stream overflows the limit'));\n    } else {\n      callback();\n    }\n  };\n};\n\nutil.inherits(WritableStreamBuffer, stream.Writable);\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/writable_streambuffer.js	(date 1503844118000)
+++ lib/writable_streambuffer.js	(revision )
@@ -27,7 +27,7 @@
   };
 
   this.getContents = function(length) {
-    if(!size) return false;
+    if(!size) return Buffer.from('');
 
     const data = new Buffer(Math.min(length || size, size));
     buffer.copy(data, 0, 0, data.length);
@@ -41,7 +41,7 @@
   };
 
   this.getContentsAsString = function(encoding, length) {
-    if(!size) return false;
+    if(!size) return '';
 
     const data = buffer.toString(encoding || 'utf8', 0, Math.min(length || size, size));
     const dataLength = Buffer.byteLength(data);
Index: test/writable_streambuffer.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'use strict';\n\nconst expect = require('chai').expect;\nconst fixtures = require('./fixtures');\nconst streamBuffer = require('../lib/streambuffer');\nconst stringStream = require('string-to-stream');\nconst BufferOverflowError = require('../lib/errors').BufferOverflowError;\n\ndescribe('WritableStreamBuffer with defaults', function() {\n  beforeEach(function() {\n    this.buffer = new streamBuffer.WritableStreamBuffer();\n  });\n\n  it('returns false on call to getContents() when empty', function() {\n    return expect(this.buffer.getContents()).to.be.false;\n  });\n\n  it('returns false on call to getContentsAsString() when empty', function() {\n    return expect(this.buffer.getContentsAsString()).to.be.false;\n  });\n\n  it('backing buffer should be default size', function() {\n    expect(this.buffer.maxSize()).to.equal(streamBuffer.DEFAULT_INITIAL_SIZE);\n  });\n\n  describe('when writing a simple string', function() {\n    beforeEach(function() {\n      this.buffer.write(fixtures.simpleString);\n    });\n\n    it('should have a backing buffer of correct length', function() {\n      expect(this.buffer.size()).to.equal(fixtures.simpleString.length);\n    });\n\n    it('should have a default max size', function() {\n      expect(this.buffer.maxSize()).to.equal(streamBuffer.DEFAULT_INITIAL_SIZE);\n    });\n\n    it('contents should be correct', function() {\n      expect(this.buffer.getContentsAsString()).to.equal(fixtures.simpleString);\n    });\n\n    it('returns partial contents correctly', function() {\n      const buf = Buffer.concat([\n        this.buffer.getContents(Math.floor(Buffer.byteLength(fixtures.simpleString) / 2)),\n        this.buffer.getContents()\n      ]);\n      expect(buf.toString()).to.equal(fixtures.simpleString);\n    });\n  });\n\n  describe('when writing a large binary blob', function() {\n    beforeEach(function() {\n      this.buffer.write(fixtures.largeBinaryData);\n    });\n\n    it('should have a backing buffer of correct length', function() {\n      expect(this.buffer.size()).to.equal(fixtures.largeBinaryData.length);\n    });\n\n    it('should have a larger backing buffer max size', function() {\n      expect(this.buffer.maxSize()).to.equal(streamBuffer.DEFAULT_INITIAL_SIZE + streamBuffer.DEFAULT_INCREMENT_AMOUNT);\n    });\n\n    it('contents are valid', function() {\n      expect(this.buffer.getContents()).to.deep.equal(fixtures.largeBinaryData);\n    });\n  });\n\n  describe('when writing some simple data to the stream', function() {\n    beforeEach(function() {\n      this.buffer = new streamBuffer.WritableStreamBuffer();\n      this.buffer.write(fixtures.simpleString);\n    });\n\n    describe('and retrieving half of it', function() {\n      beforeEach(function() {\n        this.firstStr = this.buffer.getContentsAsString('utf8', Math.floor(fixtures.simpleString.length / 2));\n      });\n\n      it('returns correct data', function() {\n        expect(this.firstStr).to.equal(fixtures.simpleString.substring(0, Math.floor(fixtures.simpleString.length / 2)));\n      });\n\n      it('leaves correct amount of data remaining in buffer', function() {\n        expect(this.buffer.size()).to.equal(Math.ceil(fixtures.simpleString.length / 2));\n      });\n\n      describe('and then retrieving the other half of it', function() {\n        beforeEach(function() {\n          this.secondStr = this.buffer.getContentsAsString('utf8', Math.ceil(fixtures.simpleString.length / 2));\n        });\n\n        it('returns correct data', function() {\n          expect(this.secondStr).to.equal(fixtures.simpleString.substring(Math.floor(fixtures.simpleString.length / 2)));\n        });\n\n        it('results in an empty buffer', function() {\n          expect(this.buffer.size()).to.equal(0);\n        });\n      });\n    });\n  });\n});\n\ndescribe('WritableStreamBuffer with a different initial size and increment amount', function() {\n  beforeEach(function() {\n    this.buffer = new streamBuffer.WritableStreamBuffer({\n      initialSize: 62,\n      incrementAmount: 321\n    });\n  });\n\n  it('has the correct initial size', function() {\n    expect(this.buffer.maxSize()).to.equal(62);\n  });\n\n  describe('after data is written', function() {\n    beforeEach(function() {\n      this.buffer.write(fixtures.binaryData);\n    });\n\n    it('has correct initial size + custom increment amount', function() {\n      expect(this.buffer.maxSize()).to.equal(321 + 62);\n    });\n  });\n});\n\ndescribe('WritableStreamBuffer with a different limit', function() {\n  beforeEach(function() {\n    this.limit = fixtures.simpleString.length - 1;\n    this.buffer = new streamBuffer.WritableStreamBuffer({\n      limit: this.limit\n    });\n  });\n\n  it('should throw an Error after the limit number of bytes were written', function() {\n    expect(this.buffer.write.bind(this.buffer, fixtures.simpleString)).to.throw(BufferOverflowError, 'Stream overflows the limit');\n    expect(this.buffer.size()).to.equal(this.limit);\n  });\n\n  it('should throw an Error after the limit number of bytes were written in 2 chunks', function() {\n    this.buffer.write(fixtures.simpleStringParts[0]);\n    expect(this.buffer.write.bind(this.buffer, fixtures.simpleStringParts[1])).to.throw(BufferOverflowError, 'Stream overflows the limit');\n    expect(this.buffer.size()).to.equal(this.limit);\n  });\n\n  it('should emit error event when the limit is surpassed', function(done) {\n    this.buffer.on('error', function(err) {\n      expect(err.name).to.be.equal(BufferOverflowError.name);\n      done();\n    });\n\n    const overflowingReadableStream = givenOverflowingReadableStream();\n    overflowingReadableStream.pipe(this.buffer);\n  });\n\n  function givenOverflowingReadableStream() {\n    return stringStream(fixtures.simpleString);\n  }\n});\n\ndescribe('When WritableStreamBuffer is written in two chunks', function() {\n  beforeEach(function() {\n    this.buffer = new streamBuffer.WritableStreamBuffer();\n    this.buffer.write(fixtures.simpleString);\n    this.buffer.write(fixtures.simpleString);\n  });\n\n  it('buffer contents are correct', function() {\n    expect(this.buffer.getContentsAsString()).to.equal(fixtures.simpleString + fixtures.simpleString);\n  });\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/writable_streambuffer.test.js	(date 1503844118000)
+++ test/writable_streambuffer.test.js	(revision )
@@ -11,12 +11,13 @@
     this.buffer = new streamBuffer.WritableStreamBuffer();
   });
 
-  it('returns false on call to getContents() when empty', function() {
-    return expect(this.buffer.getContents()).to.be.false;
+  it('returns empty Buffer on call to getContents() when empty', function() {
+    const emptyBuffer = Buffer.from('');
+    return expect(this.buffer.getContents()).to.be.deep.equal(emptyBuffer);
   });
 
-  it('returns false on call to getContentsAsString() when empty', function() {
-    return expect(this.buffer.getContentsAsString()).to.be.false;
+  it('returns empty string on call to getContentsAsString() when empty', function() {
+    return expect(this.buffer.getContentsAsString()).to.be.equal('');
   });
 
   it('backing buffer should be default size', function() {
